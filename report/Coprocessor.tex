%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%				 Coprocessor module					%
%					-----------						%
% Author: Theodoros Theodoropoulos&Adrian Schindler %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Coprocessor}

The following section describes the inner structure of the coprocessor.

It comprises a subsection regarding the incremental calculation module, and subsections regarding the buffer management and the interpolation.


\subsection{Calculation module}

\subsubsection{Incremental module}

The incremental calculation module consists of one clock-triggered process. Unlike other modules which work on an entire image it works on a tile-by-tile basis: It loads the coefficients for the new tile and then outputs the 16 x 16 pixels. Data is stored in the mfixed format, however, the version provided on the SEN website (\url{http://sen.enst.fr/ue/elec342/v_fixe}) has been modified to be C++ compatible and work with SystemC. We transformed the C union into a class with two private values which can be extracted by two public functions; in line with object-oriented programming concepts. For ease of use, we also added the + and \= operator which internally use fx\_add and fx\_copy. In addition, we added functions for debug purposes: the << operator for command line output and sc\_trace for signal tracing.

The functionality of the module can be enabled/disabled via the en signal. This does also work in the middle of a calculation, for instance during the calculation process of a tile. There a three states which are traversed during the calculation of any tile:

\begin{itemize}
\item State 0: If the start signal is high, the coefficients are loaded from the wishbone slave interface (which have been written there by the LM32 beforehand) to an internal register for each coefficient. We had to typecast the uint32\_t value output by the wishbone interface to mfixed which does not cause any problem since the upper portion of the mfixed type (which represents the digit) is unsigned. Once the start signal passes to low, the calculation will begin and the module passes to state 1.
\item State 1: In this state, the coprocessor outputs one pixel per clock cycle. It indicates this by the valid signal which is high during the whole tile calculation. The calculation process follows the incremental calculation suggested by Pacalet (\url{http://sen.enst.fr/filemanager/active?fid=326}) and therefore only consists of additions. These are performed on the internal registers. An internal counter keeps track of the number of pixels processed. After the last pixel of the tile, the coprocessor passes to state 2.
\item State 2: The Coprocessor remains in this state for one cycle and sets the finished signal high for one clock cycle to indicate that the last pixel has been processed; at the same time the valid signal is set low. Then, the coprocessor automatically passes to state 0.

\end{itemize}

The module outputs both the x- and y-coordinates by the means of two processes running in parallel. In the slave module, the y-coordinates are stored with an address offset of 40, and two separate sets of internal registers are allocated. Therefore, no conflicts can occur.

To test the operation of the incremental calculation module, we have written a dedicated testbench in SystemC which uses a formula to calculate the output x-coordinate directly for a given x and y output coordinates and coefficients. We initialised the Coprocessor thanks to a function which calculated the coefficients to be used by the incremental calculation module. This already allowed us to verify the functionality of the formulas using the mfixed type. It was sufficient to test the x-coordinate only since both the x and y coordinate follow the same principle. In particular, we used it to verify that the error between expected and observed value was not greater than 3\%; a value we judged acceptable. Errors are introduced due to the incremental calculation formula itself as well as the truncation in the mfixed format.

\subsubsection{Module's configuration: multiple register slave}

The configuration is transmitted to the module using a wishbone slave including multiple registers.
The coefficient slave has 20 internal registers to buffer the values calculated by the LM32 (10 for the x and 10 for the y coordinates) until they are accessed by the incremental calculation module. The size of the registers is 640 bits, since data is stored in 32 bits. The data format is uint32\_t due to inheritance from the wishbone slave module, which are, however, interpreted as mfixed values once they are loaded by the incremental calculation module. The module uses two internal registers: If 20 coefficients have been written, the ready signal is set high. This indicates the coprocessor that it can load these and start its calculations. In any case, all 20 coefficients must be set in a burst, i.e. writing to one register will set the ready signal down automatically until all 20 coefficients have been written. Nevertheless, no effort has been made to verify that 20 different registers have been written to and the responsibility lies with the LM32. Similarly, the internal loaded register indicates if 20 reads have been performed. The objective is to inform the LM32 if the coefficients have been loaded by the coprocessor and can thus be overwritten by new ones.
